package com.zhang.java;

import java.util.ArrayList;
import java.util.List;

/**
 * @Date 2024/6/17 08:56
 * @Author zsy
 * @Description IP 到 CIDR 类比Problem93、Problem468、IpToInt 位运算类比
 * IP地址 是一个格式化的 32位 无符号整数，每组 8位 被打印为一个十进制数字和，点字符 '.' 起到了分组的作用。
 * 例如，二进制数 00001111 10001000 11111111 01101011 ( 为清晰起见增加了空格)被格式化为IP地址将是 “15.136.255.107” 。
 * CIDR块 是一种用来表示一组特定IP地址的格式。字符串形式，由基础IP地址、斜杠和前缀长度 k 组成。
 * 它所覆盖的地址是所有IP地址的 前 k 位 与基础IP地址相同的IP地址。
 * 例如， “123.45.67.89/20” 是一个前缀长度为 20 的 CIDR块。
 * 任何二进制表示形式匹配 01111011 00101101 0100xxxx xxxxxxxx 的IP地址，其中 x 可以是 0 或 1 ，都在CIDR块覆盖的集合中。
 * 给你一个起始IP地址 ip 和我们需要覆盖的IP地址数量 n 。
 * 你的目标是使用 尽可能少的CIDR块 来 覆盖范围 [ip, ip + n - 1] 内的所有IP地址 。
 * 不应该覆盖范围之外的其他IP地址。
 * 返回 包含IP地址范围的 CIDR块 的 最短 列表。
 * 如果有多个答案，返回其中 任何 一个 。
 * <p>
 * 输入：ip = "255.0.0.7", n = 10
 * 输出：["255.0.0.7/32","255.0.0.8/29","255.0.0.16/32"]
 * 解释：
 * 需要覆盖的IP地址有:
 * - 255.0.0.7 -> 11111111 00000000 00000000 00000111
 * - 255.0.0.8 -> 11111111 00000000 00000000 00001000
 * - 255.0.0.9 -> 11111111 00000000 00000000 00001001
 * - 255.0.0.10 -> 11111111 00000000 00000000 00001010
 * - 255.0.0.11 -> 11111111 00000000 00000000 00001011
 * - 255.0.0.12 -> 11111111 00000000 00000000 00001100
 * - 255.0.0.13 -> 11111111 00000000 00000000 00001101
 * - 255.0.0.14 -> 11111111 00000000 00000000 00001110
 * - 255.0.0.15 -> 11111111 00000000 00000000 00001111
 * - 255.0.0.16 -> 11111111 00000000 00000000 00010000
 * CIDR区块“255.0.0.7/32”包含第一个地址。
 * CIDR区块255.0.0.8/29包含中间的8个地址(二进制格式为11111111 00000000 00000000 00001xxx)。
 * CIDR区块“255.0.0.16/32”包含最后一个地址。
 * 请注意，虽然CIDR区块“255.0.0.0/28”覆盖了所有的地址，但它也包括范围之外的地址，所以我们不能使用它。
 * <p>
 * 输入：ip = "117.145.102.62", n = 8
 * 输出：["117.145.102.62/31","117.145.102.64/30","117.145.102.68/31"]
 * <p>
 * 7 <= ip.length <= 15
 * ip 是一个有效的 IPv4 ，形式为 "a.b.c.d" ，其中 a, b, c,  d 是 [0, 255] 范围内的整数
 * 1 <= n <= 1000
 * 每个隐含地址 ip + x ( x < n) 都是有效的 IPv4 地址
 */
public class Problem751 {
    public static void main(String[] args) {
        Problem751 problem751 = new Problem751();
//        String ip = "255.0.0.7";
//        int n = 10;
        String ip = "117.145.102.62";
        int n = 8;
        System.out.println(problem751.ipToCIDR(ip, n));
    }

    /**
     * 位运算
     * n&(n-1)：n表示的二进制数中最低位的1置为0表示的数
     * n&(-n)=n&(~n+1)：n表示的二进制数中最低位的1表示的数
     * 从右往左找ip的二进制表示中第一个为1的位置，则到当前位置作为前缀可以得到2^n个ip地址(n：从低位到高位的下标索引)
     * 时间复杂度O(1)，空间复杂度O(1)
     *
     * @param ip
     * @param n
     * @return
     */
    public List<String> ipToCIDR(String ip, int n) {
        //ip段数组
        //注意：需要添加转义字符
        String[] arr = ip.split("\\.");
        //ip地址的整形表示
        //使用long，避免int溢出
        long num = 0;

        for (String ipSegment : arr) {
            num = (num << 8) + Integer.parseInt(ipSegment);
        }

        List<String> list = new ArrayList<>();

        // * 输入：ip = "117.145.102.62", n = 8
        // * 输出：["117.145.102.62/31","117.145.102.64/30","117.145.102.68/31"]
        //0111_0101 1001_0001 0110_0110 0011_1110

        while (n > 0) {
            //num表示的二进制数中最低位的1表示的数，则num前(32-len)位作为前缀可以得到num2个ip地址，2^len=num2
            long num2 = num & (-num);

            //num2大于n，前缀右移一位
            while (num2 > n) {
                num2 = num2 >>> 1;
            }

            //2^len=num2，即num2表示的二进制数中最高位1的位置
            int len = 0;

            while ((1L << len) != num2) {
                len++;
            }

            StringBuilder sb = new StringBuilder();

            //num转换为ip地址加入list中，作为num2个ip地址的前缀
            for (int i = 3; i >= 0; i--) {
                sb.append((num >>> (8 * i)) & 0xff).append(".");
            }

            //删除末尾"."
            sb.delete(sb.length() - 1, sb.length());
            sb.append("/").append(32 - len);
            list.add(sb.toString());

            num = num + num2;
            n = (int) (n - num2);
        }

        return list;
    }
}
